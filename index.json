[{"content":"この記事では、Lip Glossでできること、その方法をざっくり紹介します。\nLip Gloss(lipgloss) とは Lip Glossは、Goで書かれたTUI用のスタイリングライブラリです。 以下のような装飾をターミナルのテキストに適用できます。\nLip GlossのGitHubリポジトリより引用\n以下のような項目のスタイリングに対応しています。\n文字色 背景色 文字寄せ 文字囲み 特定幅での折返し などなど\u0026hellip; 以前紹介したBubble Teaを提供しているCharmというチームが開発しています。 そのため、Bubble Teaを用いたTUIアプリのスタイリングに凝りたい場合、Lip Glossが第一候補になります。\nうまく使いこなすと、こんな感じのアプリを作れます。 (GitHubのリポジトリを検索するTUIアプリ)\nLip Glossの各機能の紹介 できることと、そのコード例をセットで紹介します。\nStyle型 Style型はlipglossのメインの型です。 メソッドチェインでスタイルを設定します。 Renderメソッドを呼び出すと、渡した文字列にスタイルが適用されます。\n(各スタイルについては後述します)\nfmt.Println(\u0026#34;# lipglossでは、style型を使って文字列を装飾します\u0026#34;) var style = lipgloss.NewStyle(). Bold(true). Italic(true). Foreground(lipgloss.Color(\u0026#34;#0079FF\u0026#34;)). Background(lipgloss.Color(\u0026#34;#F6FA70\u0026#34;)). Width(40). Align(lipgloss.Center) fmt.Println(\u0026#34;## style型のRenderメソッドに文字列を渡すと、装飾された文字列が返ります\u0026#34;) fmt.Println(style.Render(\u0026#34;Hello, lipgloss!\u0026#34;)) 結果はこのようになります。\n文字、背景色の設定 Color型はlipglossで色を表現する型です。 Style型のForegroundメソッド、Backgroundメソッドに渡すことで、文字色、背景色を設定できます。\n基本的にはカラーコードで指定するとエディタのハイライトが効いたりと便利ですが、ANSIの4bit, 8bitカラーも使えます。\nfmt.Println(\u0026#34;# lipglossを使って文字、背景に色をつけることができます\u0026#34;) fmt.Println(\u0026#34;## Color型を使って色を作成できます\u0026#34;) blue := lipgloss.Color(\u0026#34;#0079FF\u0026#34;) // 24bitカラー以外にも、4bit, 8bitのカラーも使えます // lipgloss.Color(\u0026#34;5\u0026#34;) fmt.Println(\u0026#34;## style型のForeground, Backgroundメソッドには、Color型で色を指定します\u0026#34;) fmt.Println( lipgloss.NewStyle(). Foreground(lipgloss.Color(\u0026#34;#F6FA70\u0026#34;)). Background(blue). Render(\u0026#34;Colored text!\u0026#34;), ) 結果はこのようになります。\nテキストの形式設定 テキストをイタリック体、反転、太字などにできます。 それぞれ、Italic, Reverse, Bold, Underlineメソッドを使います。 (フォントが対応していない場合、通常表示になります)\nfmt.Println(\u0026#34;# テキストの形式を指定することもできます\u0026#34;) fmt.Println(lipgloss.NewStyle(). Bold(true).Render(\u0026#34;Bold text.\u0026#34;)) fmt.Println(lipgloss.NewStyle(). Italic(true).Render(\u0026#34;Italic text.\u0026#34;)) fmt.Println(lipgloss.NewStyle(). Reverse(true).Render(\u0026#34;Reversed text.\u0026#34;)) fmt.Println(lipgloss.NewStyle(). Underline(true).Render(\u0026#34;Underlined text.\u0026#34;)) 結果はこのようになります。\nパディング、マージンの設定 CSSのように、テキストの周りに余白を設けることができます。 Paddingメソッド、Marginメソッドを使います。\nPadding~, Margin~メソッドを使うと、上下左右別々に値を指定できます。 また、Padding, MarginメソッドにCSSと同じ書式でまとめて指定できます。 (例以外にも色々なパターンで渡せます)\nfmt.Println(\u0026#34;# CSSのように、パディングやマージンを指定できます\u0026#34;) // 上下左右に2文字分パディング fmt.Println(lipgloss.NewStyle().Background(blue). Padding(2).Render(\u0026#34;Padding text.\u0026#34;)) // 上下左右に2文字分マージン fmt.Println(lipgloss.NewStyle().Background(blue). Margin(2).Render(\u0026#34;Margin text.\u0026#34;)) fmt.Println(\u0026#34;## 上下左右に別々の値を指定することもできます\u0026#34;) fmt.Println( lipgloss.NewStyle().Background(blue). PaddingTop(1). PaddingRight(2). PaddingBottom(1). PaddingLeft(2). Render(\u0026#34;Complex padding text.\u0026#34;), ) fmt.Println( lipgloss.NewStyle().Background(blue). Margin(1, 2, 1, 2). // まとめることもできます(CSSと同じ書式) Render(\u0026#34;Complex margin text.\u0026#34;), ) 結果はこのようになります。\n高さ、幅の設定 Width, Heightメソッドを使うと、文字列を描画する領域のサイズを指定できます。 文字列がはみ出ると自動で折り返されます。\nまたMaxWidth, MaxHeightメソッドを使うと、文字列を描画する領域の最大サイズを指定できます。\nfmt.Println(\u0026#34;# 文字列を描画する領域のサイズを指定できます\u0026#34;) fmt.Println( lipgloss.NewStyle().Background(blue). Width(15). Height(3). Render(\u0026#34;hoge\u0026#34;), ) fmt.Println(\u0026#34;## 文字列がはみ出ると自動で折り返されます(しかも英語の場合単語単位でいい感じに)が、高さは変わります\u0026#34;) fmt.Println(lipgloss.NewStyle().Background(blue). Width(15). Height(3). Render(\u0026#34;lolem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\u0026#34;), ) 結果はこのようになります。\n文字寄せの設定 高さ、幅を指定した場合、その中での文字寄せを設定できます。 Alignメソッドにlipgloss.Center等の定数を指定します。\n複数設定すると、左下、中央上などの組み合わせも指定できます。\nfmt.Println(\u0026#34;# 文字列の描画位置を指定できます\u0026#34;) fmt.Println( lipgloss.NewStyle().Background(blue). Width(30). Align(lipgloss.Center). Render(\u0026#34;Centered text.\u0026#34;), ) fmt.Println( lipgloss.NewStyle().Background(blue). Width(30). Align(lipgloss.Right). Render(\u0026#34;Right-aligned text.\u0026#34;), ) fmt.Println(\u0026#34;## 上下の位置も指定できます\u0026#34;) fmt.Println( lipgloss.NewStyle().Background(blue). Width(30). Height(3). Align(lipgloss.Bottom). Render(\u0026#34;Bottom-aligned text.\u0026#34;), ) 結果はこのようになります。\n文字囲みの設定 Borderメソッドを使うと、文字列を囲む枠線を設定できます。\nfmt.Println(\u0026#34;# 文字を囲う枠線を書くこともできます\u0026#34;) fmt.Println( lipgloss.NewStyle(). Border(lipgloss.NormalBorder()). Render(\u0026#34;Bordered text.\u0026#34;), ) fmt.Println(\u0026#34;## 枠線には色々な種類がありますし、自分で作ることもできます\u0026#34;) fmt.Println( lipgloss.NewStyle(). Border(lipgloss.DoubleBorder()). Render(\u0026#34;Bordered text.\u0026#34;), ) 高さ、幅を測りたい Width, Height関数を使うと、文字列を描画したときの高さ、幅を測れます。 Size関数を使うと一緒に取得できます。\n裏ではmattnさんのrunewidthを使っているようです。\nfmt.Println(\u0026#34;# 文字列の幅、高さを取得できます\u0026#34;) str := \u0026#34;Lip Gloss is great.👍\\n And cute.🐱\u0026#34; fmt.Println(str) width := lipgloss.Width(str) height := lipgloss.Height(str) fmt.Printf(\u0026#34;width: %d, height: %d\\n\u0026#34;, width, height) width, height = lipgloss.Size(\u0026#34;You can get the size of the string.\u0026#34;) fmt.Printf(\u0026#34;width: %d, height: %d\\n\u0026#34;, width, height) 結果はこのようになります。\nまとめ Lip Glossの機能をざっくり紹介しました。 他にも色々な機能があり、Lip GlossのGitHubリポジトリや、Lip Glossのドキュメントに詳しく書かれています。\n今後TUIアプリを作る機会があれば、Lip Glossを使ってみてください。\nおまけ 実は、Lip GlossはBubble Teaがよく使っている絵文字を正しく表示できません! Bubblesというリポジトリで使われている\u0026rsquo;🫧\u0026rsquo;という絵文字は最近Unicodeに追加されたもので、runewidthがまだ対応していないためです。\n以下の結果は1, 2, 1になってしまいます。\nただし、相当レアケースでほとんどの場合心配しなくても大丈夫です。 (このバグで結構な時間を溶かしたので、共有してみました)\nチートシート全文 この記事で紹介した機能が確認できるコード(チートシート)です。 そのまま実行できますから、手元で色々試してみてください。\n","permalink":"https://tbistr.github.io/posts/tech/introduce_lipgloss/","summary":"この記事では、Lip Glossでできること、その方法をざっくり紹介します。\nLip Gloss(lipgloss) とは Lip Glossは、Goで書かれたTUI用のスタイリングライブラリです。 以下のような装飾をターミナルのテキストに適用できます。\nLip GlossのGitHubリポジトリより引用\n以下のような項目のスタイリングに対応しています。\n文字色 背景色 文字寄せ 文字囲み 特定幅での折返し などなど\u0026hellip; 以前紹介したBubble Teaを提供しているCharmというチームが開発しています。 そのため、Bubble Teaを用いたTUIアプリのスタイリングに凝りたい場合、Lip Glossが第一候補になります。\nうまく使いこなすと、こんな感じのアプリを作れます。 (GitHubのリポジトリを検索するTUIアプリ)\nLip Glossの各機能の紹介 できることと、そのコード例をセットで紹介します。\nStyle型 Style型はlipglossのメインの型です。 メソッドチェインでスタイルを設定します。 Renderメソッドを呼び出すと、渡した文字列にスタイルが適用されます。\n(各スタイルについては後述します)\nfmt.Println(\u0026#34;# lipglossでは、style型を使って文字列を装飾します\u0026#34;) var style = lipgloss.NewStyle(). Bold(true). Italic(true). Foreground(lipgloss.Color(\u0026#34;#0079FF\u0026#34;)). Background(lipgloss.Color(\u0026#34;#F6FA70\u0026#34;)). Width(40). Align(lipgloss.Center) fmt.Println(\u0026#34;## style型のRenderメソッドに文字列を渡すと、装飾された文字列が返ります\u0026#34;) fmt.Println(style.Render(\u0026#34;Hello, lipgloss!\u0026#34;)) 結果はこのようになります。\n文字、背景色の設定 Color型はlipglossで色を表現する型です。 Style型のForegroundメソッド、Backgroundメソッドに渡すことで、文字色、背景色を設定できます。\n基本的にはカラーコードで指定するとエディタのハイライトが効いたりと便利ですが、ANSIの4bit, 8bitカラーも使えます。\nfmt.Println(\u0026#34;# lipglossを使って文字、背景に色をつけることができます\u0026#34;) fmt.Println(\u0026#34;## Color型を使って色を作成できます\u0026#34;) blue := lipgloss.Color(\u0026#34;#0079FF\u0026#34;) // 24bitカラー以外にも、4bit, 8bitのカラーも使えます // lipgloss.Color(\u0026#34;5\u0026#34;) fmt.Println(\u0026#34;## style型のForeground, Backgroundメソッドには、Color型で色を指定します\u0026#34;) fmt.Println( lipgloss.","title":"リッチなターミナル描画を実現！ Lip Glossのススメ(ざっくりできること編)"},{"content":"Bubble Teaとは Bubble Teaは、Text User Interface(TUI)を作成するためのGo言語のライブラリ(フレームワーク)です。 以下のようなCLIアプリケーションを、比較的簡単に作成できます。\nBubble TeaのGitHubリポジトリより引用\nBubble Teaはフレームワーク的な部分があるため、アーキテクチャを理解することが重要です。 (理解しないと使えません。) この記事では、Bubble Teaのアーキテクチャについて紹介します。\nElmアーキテクチャ Bubble Teaの中心となる考え方は、Elmアーキテクチャに基づいています。 Elmアーキテクチャは、Elmという関数型のAltJS言語で考案された、Webフロントエンドのアーキテクチャです。\nElmアーキテクチャは、以下の3つの要素から構成されます。\nModel: アプリケーションの状態を表すデータ View: Modelの状態を表示するための関数(ElmではHTMLを生成) Update: Modelを更新するための関数 ユーザが何か入力したり、イベントが発生すると、ランタイムはUpdateを呼び出します。 このとき渡されるmsgは、入力やイベントを表すデータ構造です。 Updateはmsgの種類・内容に応じてModelを更新します。 (Updateはイベントハンドラのようなものですね。)\nUpdate, Viewが純粋関数であることにより、テストが容易になったりというメリットがありそうです。 この辺は関数型っぽいですね。\nBubble Teaのアーキテクチャ Bubble TeaはElmアーキテクチャをCLIのためにGo言語で実装したものと考えてもらってOKです。\nBubble Teaアプリとして実行するためには、以下のintefaceが実装されている必要があります。\ntype Model interface { Init() Cmd Update(Msg) (Model, Cmd) View() string } Viewを見ると、ElmのViewと同じようにModelから文字列(CUI)を生成する関数であることがわかります。 一方、UpdateはElmのものと少し異なり、Msgを受け取ってModelとCmdを返しています。 Modelを返しているのは、Updateが値呼びの関数であるためです。 変更後のModelを返すことでModelの変更を実現しています。\nCmdとMsg Cmd、Msgの定義は以下の通りです。\ntype Msg interface{} type Cmd func() Msg Msgはinterface{}なので、何でもアリです。 CmdはMsgを返す関数なので、これも何でもアリの関数になります。 型にはほぼ情報が無いですね。\n実際には、Cmdは主にI/O処理を実行するために使われます。 Updateから返されたCmdは、Bubble Teaランタイムによってgroutineとして非同期に実行されます。\nMsgは、Updateの引数になっていることからもわかるように、ユーザの入力やイベントを表すデータです。\n具体的な例を見てみましょう。\nMsgの種類 Bubble Teaでは、以下のようなMsgが定義されています。\ntea.KeyMsg: キー入力 tea.WindowSizeMsg: ウィンドウサイズ変更 tea.MouseMsg: マウスイベント これらのMsgは、ランタイムからUpdateに渡されます。 一方ユーザが定義するMsgには、以下のようなものがあります。\nI/O処理(Cmd)の結果を表すMsg エラーの発生を表すMsg 時間経過によるTickを表すMsg Cmdの種類 Cmdは、基本的にはユーザが定義する関数です。 以下のようなCmdが考えられます。\nHTTPリクエストを送信、結果のMsgを返すCmd ファイルを読み込み、grepした結果のMsgを返すCmd 現在時刻を取得し、Msgにして返すCmd また、Bubble Teaが提供するCmdもあります。\ntea.Batch: 複数のCmdを実行するCmd tea.Exec: 別のプログラムを実行するCmd tea.Quit: プログラムを終了するCmd Updateの構造 CmdとMsgの説明を踏まえると、Updateの構造は図のようになります。 Updateに入力されるMsgは、ユーザの入力やイベントを表すMsgと、I/O処理の結果を表すMsgの2種類があります。\nこのCmd、Msgのループを考えると、Initの意味もわかると思います。 Initはアプリケーション開始時にどんなCmdを実行するかを指定します。\n例えば、ページングがあるAPIを実行したい場合、ページ0のデータを取得するCmdをInitに指定します。 API実行結果のMsgを受け取ったら、次のページを取得するCmdを返すようにUpdateに定義します。 これで、毎回完了を待ちつつページングを順番に実行できます。\nサンプルアプリ Bubble Teaのサンプルアプリを作ってみました。\npackage main import ( \u0026#34;fmt\u0026#34; tea \u0026#34;github.com/charmbracelet/bubbletea\u0026#34; ) type model struct { counter int typedKey string } var _ tea.Model = model{} func (m model) Init() tea.Cmd { return nil } func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.KeyMsg: switch msg.String() { case \u0026#34;ctrl+c\u0026#34;: return m, tea.Quit default: m.typedKey = msg.String() m.counter++ } } return m, nil } func (m model) View() string { return fmt.Sprintf(\u0026#34;You typed: %s\\nCounter is: %d\\nCtrl+C to exit\u0026#34;, m.typedKey, m.counter) } func main() { m := model{} p := tea.NewProgram(m) p.Run() } 実行すると、入力したキーと、入力の回数が表示されます。 詳細な説明は宿題にしてみますが、Bubble Teaのコードリーディングには以下のようなコツがあります。\nまずModelが保持している状態と、Viewの処理内容を見る Updateを見て、処理するMsgの種類を把握する Msgの型ごとに処理を見ていく まとめ Bubble Teaでは、こんな感じで状態を管理しつつCmdを裏で非同期実行することで、カクツキのないCUIアプリケーションを作ることができます。 一方、トップに載せたGifようなカラフルでアニメーションがあるアプリを作るのは、この記事で説明した機能だけでは難しいです。\nBubble Teaの開発チームであるCharmが作っている、Lipglossというライブラリを使うことで、文字や背景に色をつけたり枠線を書いたりと、美麗なテキストをViewで生成できます。 また、Bubblesというコンポーネント集も提供されており、組み合わせることでリッチなUIを簡単に実現で行きます。 この辺の説明は、次回以降の記事でやっていきたいと思います。\n今後以下のような記事を書いていく予定です。\nデモアプリを使ったコード中心の説明 Lipglossの紹介 Bubblesの紹介 モデル定義のコツ 先行記事 日本語でのBubble Teaの紹介記事があまりなかったのでこの記事を書いてみました。 少ないですが、以下のような記事があります。\nhttps://motemen.hatenablog.com/entry/2022/06/introduction-to-go-bubbletea https://zenn.dev/yuzuy/articles/95e522a39a5423f5bff4 ","permalink":"https://tbistr.github.io/posts/tech/introduce_bubbletea/","summary":"Bubble Teaとは Bubble Teaは、Text User Interface(TUI)を作成するためのGo言語のライブラリ(フレームワーク)です。 以下のようなCLIアプリケーションを、比較的簡単に作成できます。\nBubble TeaのGitHubリポジトリより引用\nBubble Teaはフレームワーク的な部分があるため、アーキテクチャを理解することが重要です。 (理解しないと使えません。) この記事では、Bubble Teaのアーキテクチャについて紹介します。\nElmアーキテクチャ Bubble Teaの中心となる考え方は、Elmアーキテクチャに基づいています。 Elmアーキテクチャは、Elmという関数型のAltJS言語で考案された、Webフロントエンドのアーキテクチャです。\nElmアーキテクチャは、以下の3つの要素から構成されます。\nModel: アプリケーションの状態を表すデータ View: Modelの状態を表示するための関数(ElmではHTMLを生成) Update: Modelを更新するための関数 ユーザが何か入力したり、イベントが発生すると、ランタイムはUpdateを呼び出します。 このとき渡されるmsgは、入力やイベントを表すデータ構造です。 Updateはmsgの種類・内容に応じてModelを更新します。 (Updateはイベントハンドラのようなものですね。)\nUpdate, Viewが純粋関数であることにより、テストが容易になったりというメリットがありそうです。 この辺は関数型っぽいですね。\nBubble Teaのアーキテクチャ Bubble TeaはElmアーキテクチャをCLIのためにGo言語で実装したものと考えてもらってOKです。\nBubble Teaアプリとして実行するためには、以下のintefaceが実装されている必要があります。\ntype Model interface { Init() Cmd Update(Msg) (Model, Cmd) View() string } Viewを見ると、ElmのViewと同じようにModelから文字列(CUI)を生成する関数であることがわかります。 一方、UpdateはElmのものと少し異なり、Msgを受け取ってModelとCmdを返しています。 Modelを返しているのは、Updateが値呼びの関数であるためです。 変更後のModelを返すことでModelの変更を実現しています。\nCmdとMsg Cmd、Msgの定義は以下の通りです。\ntype Msg interface{} type Cmd func() Msg Msgはinterface{}なので、何でもアリです。 CmdはMsgを返す関数なので、これも何でもアリの関数になります。 型にはほぼ情報が無いですね。\n実際には、Cmdは主にI/O処理を実行するために使われます。 Updateから返されたCmdは、Bubble Teaランタイムによってgroutineとして非同期に実行されます。\nMsgは、Updateの引数になっていることからもわかるように、ユーザの入力やイベントを表すデータです。","title":"簡単にTUIが作れる！Bubble Teaのススメ(アーキテクチャ編)"},{"content":" Introduction なんだか、バイト先や研究室でLinuxの基本知識的な部分を聞かれたり、教えたりすることが多い。 最近、Linux関連の良い本が増えていて、初級者～中級者くらいまで一気に駆け抜けられる環境が整いつつある。 そこで、Linuxをユーザとして、開発者として使うための(個人的)最短ルートを考えてみた。\nまだまだブラッシュアップ段階で、特にWebの資料について触れられていないので、随時更新していく予定。\nユーザとして(初級編) ユーザとしての入門「新しいLinuxの教科書」 「新しいLinuxの教科書」は、まさにLinuxの教科書的な存在で、「ディストリビューションってなに?」なところから丁寧に解説してくれて、Linuxの基本的な使い方を学べる。 とりあえず、Linux触ったことない人にはこれを読んで欲しい。\n新しいLinuxの教科書\nシェル入門 「シェルスクリプト基本リファレンス」 「新しいLinuxの教科書」では、当然シェルの基本的な使い方やメジャーなコマンドについては紹介されている。 一方で、少し発展的な使い方やシェル(bash)自体の機能について網羅的に紹介されているわけではない。\nシェルスクリプト基本リファレンスには、シェル自体の機能から応用的なコマンドまで幅広く辞書的に載っている。 当然、manコマンドを使って調べることもできるが、予めパラパラと見ておくことで、「この機能はたしかコマンドとして提供されたな」みたいなあたりを付けることができる。 「できる、できない」の判断がついていると、Webで検索する際にも迷子になりにくい。\n(最近では、ChatGPTに聞けばほとんどのコマンド、オプションを教えてくれるため、わざわざ逆引き的に覚えておく必要はないかもしれない)\nシェルスクリプト基本リファレンス\n開発者、管理者として(初級編) Linuxの上でソフトを開発したり、Linuxサーバにアプリをデプロイしたりする場合、ユーザとしての知識だけでは足りないことがある。 例えば、Docker(仮想化技術)を使う場合、ファイルシステムやネットワークについての基本的な知識が必要になる。\nLinuxの裏側に入門する「［試して理解］Linuxのしくみ―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識」 この本はLinuxの中身、特にカーネルと呼ばれる根幹部分で何をしているかを知るための入門書である。 最近のニーズに対応するため、仮想マシン、コンテナという副題がついているものの、OSとしてのLinuxの上に広がる概念、用語を初学者にもわかりやすく解説している。 (個人的には、ここ最近出たLinux関連本の中ではイチオシ)\n著者の武内覚(sat)さんは、YouTubeチャンネルでもLinux関連のトピックを解説しておられて、こちらもおすすめ。 こちらは体系的というより、動画ごとにトリビアルな内容となっている。 興味のある分野から観てみることをおすすめする。\nLinuxのしくみ satさんのYouTubeチャンネル\nユーザ、開発者、管理者として(中級編) ちょっと扱いに迷ったが、このレベルになるとユーザ、開発者、管理者という区分けはあまり意味がなく、どの立場においても知っておくべき内容になってくる。 よって、「中級編」としてまとめることにした。\n更にシェルでできることを増やす「シェル・ワンライナー160本ノック」 この本は、シェルのコマンドを組み合わせて1行のコマンド列で何かを実現するという「ワンライナー」を中心に、コマンド、シェルの機能を学べるドリルである。 本当に160本の例題が載っており、それぞれの例題に解説、別解が丁寧に付いている。 全部通すのはかなりしんどいが、やりきると多分シェルについてはかなり理解が深まるはず。 (僕はパラパラ読みで全部手を動かしたわけではない…ハズカシイ)\nシェル・ワンライナー160本ノック\n最近のLinuxツールチェイン、ユースケースを知る「入門 モダンLinux」 Linuxはカスタム性が強く、ツールなどのトレンドが変わりやすい (もちろん変わらないインタフェースもあるが)。 この本では、最近のLinux周辺ツール、環境、ユーザがどんな使い方をしているか、などについて解説している。\n例えば、シェルと一口に言っても、bash、zsh、fishなど様々なシェルがある。 この本には、各シェルがどんな特徴を持っているか、注意点はなにか、といったことが載っている。 また、eBPFなど最近のLinuxカーネルの機能についても解説がある。 これら最新の動向、流行りを知っておくと、Webや雑誌の技術記事に関する解像度がクリアになり、情報収集のスピードが加速度的に上がる。 そんな意味でもこの本はおすすめ。\nちなみに、この本の翻訳には先述したsatさんも関わっている。 再度になるが、satさんのYouTubeチャンネルではこの本で扱うような最新のトピックにも言及しており、本と一緒に楽しむことができる。\n入門 モダンLinux\n管理者としての知識を深める「スーパーユーザーなら知っておくべきLinuxシステムの仕組み」 名前のとおり、スーパーユーザ(管理者)が知っておくべきLinuxの仕組み、使い方についてかなり広範に、詳細に扱っている本である。 ぶっちゃけ、僕も読めていない節があったり、これまで紹介してきたリソースに比べて相当に難しく、実践的な内容になっている。 (正直、上級編として別枠にしても良い)\n全ては理解できなくても、仮想マシンなどで手を動かしながら読み進めることで、周辺知識も含めたLinuxの理解がかなり深まる。 また、必要となってからリファレンス的に用いることも出来るので、一度パラ読みしてみることをおすすめする。\nスーパーユーザーなら知っておくべきLinuxシステムの仕組み\nまとめ こんな感じのルートを最近はおすすめしている。 また、シェルについて省略したこんなルートも良いかもしれない。\n新しいLinuxの教科書 Linuxのしくみ 入門 モダンLinux スーパーユーザーなら知っておくべきLinuxシステムの仕組み この記事については、特にWebのリソースを中心にまだまだ漏れがありそうなので、都度更新していく予定。 なにかおすすめのリソースがあったら教えてください。\nあとは、上級編としてカーネルのソース、デバドラみたいな山を登っていくルートを考えてもおもしろいかもしれない。 が、そもそも僕が登らないと書けない…。 頑張ります、はい。\n","permalink":"https://tbistr.github.io/posts/tech/linux_short_course/","summary":"Introduction なんだか、バイト先や研究室でLinuxの基本知識的な部分を聞かれたり、教えたりすることが多い。 最近、Linux関連の良い本が増えていて、初級者～中級者くらいまで一気に駆け抜けられる環境が整いつつある。 そこで、Linuxをユーザとして、開発者として使うための(個人的)最短ルートを考えてみた。\nまだまだブラッシュアップ段階で、特にWebの資料について触れられていないので、随時更新していく予定。\nユーザとして(初級編) ユーザとしての入門「新しいLinuxの教科書」 「新しいLinuxの教科書」は、まさにLinuxの教科書的な存在で、「ディストリビューションってなに?」なところから丁寧に解説してくれて、Linuxの基本的な使い方を学べる。 とりあえず、Linux触ったことない人にはこれを読んで欲しい。\n新しいLinuxの教科書\nシェル入門 「シェルスクリプト基本リファレンス」 「新しいLinuxの教科書」では、当然シェルの基本的な使い方やメジャーなコマンドについては紹介されている。 一方で、少し発展的な使い方やシェル(bash)自体の機能について網羅的に紹介されているわけではない。\nシェルスクリプト基本リファレンスには、シェル自体の機能から応用的なコマンドまで幅広く辞書的に載っている。 当然、manコマンドを使って調べることもできるが、予めパラパラと見ておくことで、「この機能はたしかコマンドとして提供されたな」みたいなあたりを付けることができる。 「できる、できない」の判断がついていると、Webで検索する際にも迷子になりにくい。\n(最近では、ChatGPTに聞けばほとんどのコマンド、オプションを教えてくれるため、わざわざ逆引き的に覚えておく必要はないかもしれない)\nシェルスクリプト基本リファレンス\n開発者、管理者として(初級編) Linuxの上でソフトを開発したり、Linuxサーバにアプリをデプロイしたりする場合、ユーザとしての知識だけでは足りないことがある。 例えば、Docker(仮想化技術)を使う場合、ファイルシステムやネットワークについての基本的な知識が必要になる。\nLinuxの裏側に入門する「［試して理解］Linuxのしくみ―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識」 この本はLinuxの中身、特にカーネルと呼ばれる根幹部分で何をしているかを知るための入門書である。 最近のニーズに対応するため、仮想マシン、コンテナという副題がついているものの、OSとしてのLinuxの上に広がる概念、用語を初学者にもわかりやすく解説している。 (個人的には、ここ最近出たLinux関連本の中ではイチオシ)\n著者の武内覚(sat)さんは、YouTubeチャンネルでもLinux関連のトピックを解説しておられて、こちらもおすすめ。 こちらは体系的というより、動画ごとにトリビアルな内容となっている。 興味のある分野から観てみることをおすすめする。\nLinuxのしくみ satさんのYouTubeチャンネル\nユーザ、開発者、管理者として(中級編) ちょっと扱いに迷ったが、このレベルになるとユーザ、開発者、管理者という区分けはあまり意味がなく、どの立場においても知っておくべき内容になってくる。 よって、「中級編」としてまとめることにした。\n更にシェルでできることを増やす「シェル・ワンライナー160本ノック」 この本は、シェルのコマンドを組み合わせて1行のコマンド列で何かを実現するという「ワンライナー」を中心に、コマンド、シェルの機能を学べるドリルである。 本当に160本の例題が載っており、それぞれの例題に解説、別解が丁寧に付いている。 全部通すのはかなりしんどいが、やりきると多分シェルについてはかなり理解が深まるはず。 (僕はパラパラ読みで全部手を動かしたわけではない…ハズカシイ)\nシェル・ワンライナー160本ノック\n最近のLinuxツールチェイン、ユースケースを知る「入門 モダンLinux」 Linuxはカスタム性が強く、ツールなどのトレンドが変わりやすい (もちろん変わらないインタフェースもあるが)。 この本では、最近のLinux周辺ツール、環境、ユーザがどんな使い方をしているか、などについて解説している。\n例えば、シェルと一口に言っても、bash、zsh、fishなど様々なシェルがある。 この本には、各シェルがどんな特徴を持っているか、注意点はなにか、といったことが載っている。 また、eBPFなど最近のLinuxカーネルの機能についても解説がある。 これら最新の動向、流行りを知っておくと、Webや雑誌の技術記事に関する解像度がクリアになり、情報収集のスピードが加速度的に上がる。 そんな意味でもこの本はおすすめ。\nちなみに、この本の翻訳には先述したsatさんも関わっている。 再度になるが、satさんのYouTubeチャンネルではこの本で扱うような最新のトピックにも言及しており、本と一緒に楽しむことができる。\n入門 モダンLinux\n管理者としての知識を深める「スーパーユーザーなら知っておくべきLinuxシステムの仕組み」 名前のとおり、スーパーユーザ(管理者)が知っておくべきLinuxの仕組み、使い方についてかなり広範に、詳細に扱っている本である。 ぶっちゃけ、僕も読めていない節があったり、これまで紹介してきたリソースに比べて相当に難しく、実践的な内容になっている。 (正直、上級編として別枠にしても良い)\n全ては理解できなくても、仮想マシンなどで手を動かしながら読み進めることで、周辺知識も含めたLinuxの理解がかなり深まる。 また、必要となってからリファレンス的に用いることも出来るので、一度パラ読みしてみることをおすすめする。\nスーパーユーザーなら知っておくべきLinuxシステムの仕組み\nまとめ こんな感じのルートを最近はおすすめしている。 また、シェルについて省略したこんなルートも良いかもしれない。\n新しいLinuxの教科書 Linuxのしくみ 入門 モダンLinux スーパーユーザーなら知っておくべきLinuxシステムの仕組み この記事については、特にWebのリソースを中心にまだまだ漏れがありそうなので、都度更新していく予定。 なにかおすすめのリソースがあったら教えてください。","title":"Linux Short Course"},{"content":"2023年上半期良かった曲 2023年も半分過ぎましたけど、体感起きてる時間の3分の2くらいはSpotifyで音楽聞いてるので、良かった曲を40曲紹介します。 プレイリスト公開しているので、こちらから聞いてみてね。\nSpotify契約していない貧乏人のためちょっとだけ聴けるリンクも貼っておきます。\n本編 ","permalink":"https://tbistr.github.io/posts/music/2023h1-my-best-hits/","summary":"2023年上半期良かった曲 2023年も半分過ぎましたけど、体感起きてる時間の3分の2くらいはSpotifyで音楽聞いてるので、良かった曲を40曲紹介します。 プレイリスト公開しているので、こちらから聞いてみてね。\nSpotify契約していない貧乏人のためちょっとだけ聴けるリンクも貼っておきます。\n本編 ","title":"2023年上半期に聞いてよかった曲"},{"content":"Type alias Type aliasはGo 1.9で追加された機能です。 以下のようなsyntaxで既存の型に別名を定義できます。\ntype aliasT = string 普通のDefined typeと何が違うのかというと、定義された型と元になる型との同一性が異なります。 具体的にDefined typeでは以下のように独自メソッドを生やすことができる一方、Type aliasにはメソッドを追加できません。\ntype defT string func (d defT) SomeMethod() { // これは出来る } type aliasT = string func (d aliasT) SomeMethod() { // これは出来ない! } これはaliasT型がstringと完全に同じとみなされているからで、以下のようなコードはコンパイルが通ります。\ntype aliasT = string func f() string { var a aliasT return a } 使い所 導入経緯的には、大規模コードのAPI変更をサポートするために作られた機能だそうで、普通のコードベースだと一生体験する機会がなさそうです。 そんな感じで微妙にどこに使えば良いか迷うこの機能ですが、最近書いたコードで良さそうなユースケースを見つけました。\n導入対象 対象となるプロジェクトは自作のAtCoder関連のライブラリ「atcoder-go」で、注目したい部分は以下のようなファイル群です。\natcodergo |---model // 外部に公開する構造体を定義 | |---model.go |---parse // HTMLパーサー、セレクタを使ってHTML→構造体の変換 | |---task.go | |---(etc.go...) |---task.go // 外部から操作するメソッドを定義 |---(etc.go...) 各ファイルの内容はざっくり、こんな感じです。\n// model/model.go type Task struct { Name string IdName string ID string } // parse/task.go func Task(doc pig.Node) []*model.Task { tasks := []*model.Task{} // pig(自作ライブラリ)を使ってHTMLをパース return tasks } // /task.go func (c *Client) Task() []*model.Task { tasks := []*model.Task{} // 通信してページを取得 tasks = parse.Task(doc) return tasks } 以下のようなことを考慮してこの構成になりました。\nparseだけするパッケージを分けたい→parse/追加 テストを書く場合parse関数は分離するべき parse~()みたいなprefixを付けた関数が量産されるのは嫌 parse/の中の関数で返す型と、atcodergo/で返す型は共通化したい→model/追加 導入 atcodergo/task.goをこのように変更しました。\n// /task.go type Task = model.Task func (c *Client) Task() []*Task { tasks := []*Task{} // 通信してページを取得 tasks = parse.Task(doc) return tasks } まとめ この書き方には以下のような利点があります。\n外部から見える型がmodel.Taskのように一段深くならない Defined typeと異なり型変換が不要 型変換については、もしDefine typeを使った場合にはunsafe.Pointerやunsafe.Sliceを使用してキャスト処理を書く必要があります。 この処理自体はそんなに長くもないのですが、やはり元の型との整合性を自分で担保しないといけないのはちょっと怖いです。\n一方この書き方には、型のドキュメント(godoc)が空になり、基になる型の情報がわかりにくくなるというデメリットがあります。 また、Go的には割りと大規模なコードベースでも1パッケージにフラットに書く風潮があったりするので、そちらを採用する場合は完全に不要になります。 今回はHTMLセレクタを自作しており、それを使っている部分を最小化、なるべくテスタブルにしたいという事情があります。\nこんな感じで、外部に公開したい型を参照しやすくするという用途では結構使えるんじゃないかと思っています。\nおまけ(Alias typeの導入経緯) Type aliasの導入経緯はこのページから読むことが出来ます。 ざっくり言うと大規模コードベースでパッケージを整理する際、一気にすべてのコードを変更しなくて済むようにtype newT = oldTのように書くことを想定しています。\n","permalink":"https://tbistr.github.io/posts/tech/golang_typealias/","summary":"Type alias Type aliasはGo 1.9で追加された機能です。 以下のようなsyntaxで既存の型に別名を定義できます。\ntype aliasT = string 普通のDefined typeと何が違うのかというと、定義された型と元になる型との同一性が異なります。 具体的にDefined typeでは以下のように独自メソッドを生やすことができる一方、Type aliasにはメソッドを追加できません。\ntype defT string func (d defT) SomeMethod() { // これは出来る } type aliasT = string func (d aliasT) SomeMethod() { // これは出来ない! } これはaliasT型がstringと完全に同じとみなされているからで、以下のようなコードはコンパイルが通ります。\ntype aliasT = string func f() string { var a aliasT return a } 使い所 導入経緯的には、大規模コードのAPI変更をサポートするために作られた機能だそうで、普通のコードベースだと一生体験する機会がなさそうです。 そんな感じで微妙にどこに使えば良いか迷うこの機能ですが、最近書いたコードで良さそうなユースケースを見つけました。\n導入対象 対象となるプロジェクトは自作のAtCoder関連のライブラリ「atcoder-go」で、注目したい部分は以下のようなファイル群です。\natcodergo |---model // 外部に公開する構造体を定義 | |---model.go |---parse // HTMLパーサー、セレクタを使ってHTML→構造体の変換 | |---task.go | |---(etc.","title":"Type aliasの使い所を提案"},{"content":"概要 Goでライブラリを作るとき、呼び出し元でどのようにエラーハンドリングするか想像して実装することが出来ていますか? この記事では、minimalなサンプルを提示し、Goでの独自エラー実装について紹介します。\nTODO: Asについては、僕がユースケースを理解できていないので書いていません。\n前提 Goの文法は分かっているということを仮定します。\nライブラリ利用者側から見たGoのエラー処理について ご存知の通り、Goには高級?なエラー処理機構がありません。 関数が正常に終了したかどうかは、if文によって判定します。\nfunc someFunc() error {...} err := someFunc() if err != nil { // 何か処理 } また、errorインターフェースの定義は以下のようになっていて、.Error()によって出力する文字列を作成できれば、どんなものでもerror型として扱うことが出来ます。\ntype error interface{ Error() string } そのため、ライブラリ作成者には独自エラーの構造体に対して、Error() stringを実装することが要求されます。\ntype myError struct{ // some member } func (err *myError) Error() string{ return \u0026#34;\u0026#34; } Unwrapの利用 上記のような独自エラーには、エラーが起こった原因となるエラーが何か判別出来ないという欠点がありました。 (正確には、判別のための標準的なインターフェースがなかった。)\nGo1.13以降、エラー原因の特定インターフェースとして、errors.Unwrap(err) errorという関数が使えます。 これによって、ライブラリ使用者はエラーを引き起こしたエラーを取得することが出来ます。\nerr := someFunc() if err != nil { inner := errors.Unwrap(err) fmt.Printf(\u0026#34;内部エラーはこれ: %v\u0026#34;, inner) } Isの利用 エラー原因特定のユースケースとして、エラー種別によって処理を分けるというケースがあります。 このとき、エラーの原因の原因の原因\u0026hellip;のようにエラーが連鎖的にwrapされている場合、あるエラーと、その原因となったエラーの種別が同じものかを判定する必要があります。\nそこで、errors.Is(err, target error) boolという関数が用意されています。 これによって、errがnilになるまでUnwrapし続け、targetと等しいかチェック、処理を分けることが出来ます。\nerr := someFunc() if err != nil { if errors.Is(err, ErrNotFound) { // なにか処理 }else if errors.Is(err, ErrPermissionDenied) { // なにか処理 } } ライブラリの実装者がすべき独自エラーの実装について Unwrapの実装 Unwrap機能を提供するために、独自エラーはエラーを返すきっかけとなった内部エラーを保持しておく必要があります。 また、error型として扱うために、Error() stringメソッドを実装する必要があります。\ntype myError struct { innner error } func (err *myError)Error() string { return \u0026#34;myError: \u0026#34; + err.innner.Error() } ただ、これだけでは正しくUnwrapしてくれません。 そこで、errors.Unwrapの実装を見てどうすればいいか確認してみましょう。\nhttps://cs.opensource.google/go/go/+/refs/tags/go1.19.3:src/errors/wrap.go;l=14\n// Unwrap returns the result of calling the Unwrap method on err, if err\u0026#39;s // type contains an Unwrap method returning error. // Otherwise, Unwrap returns nil. func Unwrap(err error) error { u, ok := err.(interface { Unwrap() error }) if !ok { return nil } return u.Unwrap() } 関数内の最初に、err.(interface {Unwrap() error})という式があります。 これはerrが、無名interfaceであるinterface {Unwrap() error}を実装している型に変換可能かどうか、実行時にチェックするロジックです。 (型アサーション)\nすなわち、Unwrapに投げられるエラーには、Unwrap() errorが実装されていることが期待されます。 (注意!errors.Unwrapとはシグネチャが違います)\nmyErrorにも、Unwrap() errorを実装してみます。\nfunc (err *myError)Unwrap() error { return err.innner } func main() { err := someMyFunc() // 適当な関数 innerErr := errors.Unwrap(err) fmt.Printf(\u0026#34;内部エラー発見可能: %v\u0026#34;, innerErr) } Isの実装 次に、errors.IsがmyErrorについて呼び出された状況を考えます。\nerr := someMyFunc() // *myErrorを返す関数 if errors.Is(err, fs.ErrNotExist) { // どこかでファイルが存在しないことによるエラーが発生した } 前節でUnrwapを実装したため、再帰的にerrを辿っていって、どこかでfs.ErrNotExistに当たらないかをチェックすることが出来ます。\nしかし、独自エラー自体に種別があり、その種別について判定したい場合にはどうすれば良いでしょう。 とりあえず、errors.Isの実装を見てみます。\nhttps://cs.opensource.google/go/go/+/refs/tags/go1.19.3:src/errors/wrap.go;l=40\n// Is reports whether any error in err\u0026#39;s chain matches target. // // The chain consists of err itself followed by the sequence of errors obtained by // repeatedly calling Unwrap. // // An error is considered to match a target if it is equal to that target or if // it implements a method Is(error) bool such that Is(target) returns true. // // An error type might provide an Is method so it can be treated as equivalent // to an existing error. For example, if MyError defines // //\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist } // // then Is(MyError{}, fs.ErrExist) returns true. See syscall.Errno.Is for // an example in the standard library. An Is method should only shallowly // compare err and the target and not call Unwrap on either. func Is(err, target error) bool { if target == nil { return err == target } isComparable := reflectlite.TypeOf(target).Comparable() for { if isComparable \u0026amp;\u0026amp; err == target { return true } if x, ok := err.(interface{ Is(error) bool }); ok \u0026amp;\u0026amp; x.Is(target) { return true } // TODO: consider supporting target.Is(err). This would allow // user-definable predicates, but also may allow for coping with sloppy // APIs, thereby making it easier to get away with them. if err = Unwrap(err); err == nil { return false } } } Unwrapより少し複雑ですが、\ntargetが比較可能でerrと等しければtrue errがIs(error) boolを実装する型であれば、err.Is(target)を使って判定 上のステップがfalseなら、Unwrapしてループ→1へ といった処理になっています。 実装から分かるように、独自エラーに種別がある場合Is(error) boolメソッドの実装が必要です。\nまずは、独自エラーに種別を定義してみます。 Error() stringも改良してみましょう\ntype myError struct { kind myStatus inner error } type myStatus string const ( statusNotFound = myStatus(\u0026#34;NotFound\u0026#34;) statusUnauthorized = myStatus(\u0026#34;Unauthorized\u0026#34;) statusCatInterfered = myStatus(\u0026#34;CatInterfered\u0026#34;) ) func (err *myError) Error() string { return string(err.kind) + \u0026#34;: \u0026#34; + err.inner.Error() } myStatus型を作るor作らない、stringではなくintにする等、状況によって実装は変わりますが、myErrorに 種別を保持するメンバ(kind)を加えるというのは共通するはずです。\n続いて、myErrorに対してIs(error) boolメソッドを実装します。 また、ライブラリ利用者がerrors.Isの引数targetに入れるためのエラー種別を公開する変数を定義する必要があります。 (例えば、先程例示したfs.ErrNotExistのようなものです)\nvar ( ErrNotFound = myError{statusNotFound, nil} ErrUnauthorized = myError{statusUnauthorized, nil} ErrCatInterfered = myError{statusCatInterfered, nil} ) func (err *myError) Is(target error) bool { // `kind`で比較する前に、型変換で`myError`として扱えるかをチェック t, ok := target.(*myError) return ok \u0026amp;\u0026amp; err.kind == t.kind } このように、「myError型として扱える」、「kindメンバが等しい」という2条件が揃ったときに2つのエラーが正しいとすると良いと思います。 またライブラリの利用者は、errors.Is(err, ErrNotFound)のように利用するものと想定しています。\n実装のまとめ これまでの実装で、以下のようなコードが出来上がります。\nおまけfmt.Errorf()を使うべきか fmt.Errorf()のフォーマット指定子に%wを使うことで、渡されたエラーをwrapしたエラーを作ってくれます。 ただし、実装を見るとわかりますが、 https://cs.opensource.google/go/go/+/refs/tags/go1.19.3:src/fmt/errors.go;l=17\ntype wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } のように、wrapErrorという構造体に表示文字列と内部エラーを保持しているだけです。 すなわち、一番外側のエラーの種別情報に関して完全に捨てることになります。 個人的には、ライブラリのコードではfmt.Errorfは使わずに独自エラーを定義してあげて、有り得るエラーをvarで提示した方が親切だと思います。\n独自エラーを作らないという考え 薄いラッパーや、関数毎に返すエラーが決まりきっている場合、下のレイヤのエラーをそのまま返すという選択もありだと思います。\n例えば、os.Openのような関数ではos.PathErrorを返すとしています。 しかし、実体はfs.PathErrorです。\nまた、そんなfsパッケージの中でも一部のエラーはoserrorのものをそのまま返しています。 https://cs.opensource.google/go/go/+/refs/tags/go1.19.3:src/io/fs/fs.go;l=136\n// Generic file system errors. // Errors returned by file systems can be tested against these errors // using errors.Is. var ( ErrInvalid = errInvalid() // \u0026#34;invalid argument\u0026#34; ErrPermission = errPermission() // \u0026#34;permission denied\u0026#34; ErrExist = errExist() // \u0026#34;file already exists\u0026#34; ErrNotExist = errNotExist() // \u0026#34;file does not exist\u0026#34; ErrClosed = errClosed() // \u0026#34;file already closed\u0026#34; ) func errInvalid() error { return oserror.ErrInvalid } func errPermission() error { return oserror.ErrPermission } func errExist() error { return oserror.ErrExist } func errNotExist() error { return oserror.ErrNotExist } func errClosed() error { return oserror.ErrClosed } ","permalink":"https://tbistr.github.io/posts/tech/golang_error_impl/","summary":"概要 Goでライブラリを作るとき、呼び出し元でどのようにエラーハンドリングするか想像して実装することが出来ていますか? この記事では、minimalなサンプルを提示し、Goでの独自エラー実装について紹介します。\nTODO: Asについては、僕がユースケースを理解できていないので書いていません。\n前提 Goの文法は分かっているということを仮定します。\nライブラリ利用者側から見たGoのエラー処理について ご存知の通り、Goには高級?なエラー処理機構がありません。 関数が正常に終了したかどうかは、if文によって判定します。\nfunc someFunc() error {...} err := someFunc() if err != nil { // 何か処理 } また、errorインターフェースの定義は以下のようになっていて、.Error()によって出力する文字列を作成できれば、どんなものでもerror型として扱うことが出来ます。\ntype error interface{ Error() string } そのため、ライブラリ作成者には独自エラーの構造体に対して、Error() stringを実装することが要求されます。\ntype myError struct{ // some member } func (err *myError) Error() string{ return \u0026#34;\u0026#34; } Unwrapの利用 上記のような独自エラーには、エラーが起こった原因となるエラーが何か判別出来ないという欠点がありました。 (正確には、判別のための標準的なインターフェースがなかった。)\nGo1.13以降、エラー原因の特定インターフェースとして、errors.Unwrap(err) errorという関数が使えます。 これによって、ライブラリ使用者はエラーを引き起こしたエラーを取得することが出来ます。\nerr := someFunc() if err != nil { inner := errors.Unwrap(err) fmt.Printf(\u0026#34;内部エラーはこれ: %v\u0026#34;, inner) } Isの利用 エラー原因特定のユースケースとして、エラー種別によって処理を分けるというケースがあります。 このとき、エラーの原因の原因の原因\u0026hellip;のようにエラーが連鎖的にwrapされている場合、あるエラーと、その原因となったエラーの種別が同じものかを判定する必要があります。","title":"Go言語で独自エラーを実装するときの実例(ライブラリ編)"},{"content":"経緯 相変わらずDocker上のMySQLをいじっている。\nMySQLサーバに対して、毎回コンテナに入ってmysqlプロンプトを出してコマンドを打つのがめんどくさいので、webベースのGUIサーバを追加することにした。 このとき、.envで指定しているMySQL用のユーザ情報について、同じ値を別の名前で環境変数として指定する必要があった。\n環境 docker-composeファイルは以下の通り。\nversion: \u0026#39;3.8\u0026#39; services: db: container_name: db image: mysql:8.0 environment: - LANG=ja_JP.UTF-8 tty: true volumes: - type: volume source: test_volume target: /var/lib/mysql networks: - test_network volumes: test_volume: name: test_volume networks: test_network: external: true .envはこの内容。\nMYSQL_DATABASE=test_database MYSQL_USER=test_user MYSQL_PASSWORD=password MYSQL_ROOT_PASSWORD=root_password 課題 今の環境に、phpmyadminというMySQLのGUIツールを新しいサービスとして導入する。 具体的に以下の内容を追加したい。\ndb-gui: container_name: db-gui image: phpmyadmin/phpmyadmin environment: - LANG=ja_JP.UTF-8 tty: true ports: - 8080:80 depends_on: - db networks: - test_network このとき、phpmyadminコンテナには環境変数PMA_HOSTS, PMA_USER, PMA_PASSWORDを渡して接続先と認証の情報を教える必要がある。 しかし、PMA_HOSTSはサービス名(db)を直書きすれば良いとして(networkが設定されてるので、サービス名←→アドレスができる)、他の2つの値は.envのMYSQL_USER, MYSQL_PASSWORDと同一である。\n愚直な方法として、.envにPMA_USER, PMA_PASSWORDを追加しても良い。 が、同じ値(しかも認証情報!)を2回書くのはメンテナンス性も悪いし、ミスを誘発しやすい。\n解決方法 今回、環境変数にエイリアスを設定することでこの問題を解決した。\nこのように、db-guiサービスのパラメータにenvironment:を設定して、値を${envで設定された変数名}とすることで、db-guiで変数が読まれる際にはMYSQL_USERの値で置き換えられる。\nenvironment: - LANG=ja_JP.UTF-8 - PMA_ARBITRARY=1 - PMA_HOSTS=db - PMA_USER=${MYSQL_USER} - PMA_PASSWORD=${MYSQL_PASSWORD} おまけ 環境変数の評価タイミング的に、environment設定時に展開されるのか、参照時に展開されているのかが気になったので確認してみた。 つまり、PMA_USER=\u0026quot;${MYSQL_USER}\u0026quot;なのか、PMA_USER=\u0026quot;test_user\u0026quot;かということである。\n試すのは簡単で、\ndocker compose exec db-gui bash \u0026gt; echo $PMA_USER test_user \u0026gt; MYSQL_USER=hoge \u0026gt; echo $PMA_USER test_user 上書き後の最後の結果がtest_userなので、environmentに設定した変数はコンテナ作成時に評価されることが分かる。 更に複数の手段で指定される環境変数が、どの順番で読み込まれるかも分かる。 例えば、.envにTEST=$PMA_HOSTSなどとenvironmentで指定された変数を利用しようとしても、デフォルト値の\u0026quot;\u0026quot;として評価される。\n一応確認してみるとこのようになる。\ndocker compose exec db-gui bash \u0026gt; echo $TEST \u0026gt; echo $PMA_HOSTS db 逆に応用テクとしてこんな風に.envの内容を利用して複雑な変数を用意することもできたりする。\nCOMPLEX=${MYSQL_PASSWORD}concat_ENVS${MYSQL_PASSWORD}hogehuga ","permalink":"https://tbistr.github.io/posts/tech/docker-compose%E3%81%A7%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%81%AE%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9%E3%82%92%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84/","summary":"経緯 相変わらずDocker上のMySQLをいじっている。\nMySQLサーバに対して、毎回コンテナに入ってmysqlプロンプトを出してコマンドを打つのがめんどくさいので、webベースのGUIサーバを追加することにした。 このとき、.envで指定しているMySQL用のユーザ情報について、同じ値を別の名前で環境変数として指定する必要があった。\n環境 docker-composeファイルは以下の通り。\nversion: \u0026#39;3.8\u0026#39; services: db: container_name: db image: mysql:8.0 environment: - LANG=ja_JP.UTF-8 tty: true volumes: - type: volume source: test_volume target: /var/lib/mysql networks: - test_network volumes: test_volume: name: test_volume networks: test_network: external: true .envはこの内容。\nMYSQL_DATABASE=test_database MYSQL_USER=test_user MYSQL_PASSWORD=password MYSQL_ROOT_PASSWORD=root_password 課題 今の環境に、phpmyadminというMySQLのGUIツールを新しいサービスとして導入する。 具体的に以下の内容を追加したい。\ndb-gui: container_name: db-gui image: phpmyadmin/phpmyadmin environment: - LANG=ja_JP.UTF-8 tty: true ports: - 8080:80 depends_on: - db networks: - test_network このとき、phpmyadminコンテナには環境変数PMA_HOSTS, PMA_USER, PMA_PASSWORDを渡して接続先と認証の情報を教える必要がある。 しかし、PMA_HOSTSはサービス名(db)を直書きすれば良いとして(networkが設定されてるので、サービス名←→アドレスができる)、他の2つの値は.envのMYSQL_USER, MYSQL_PASSWORDと同一である。","title":"DockerComposeで環境変数のエイリアスを作りたい"},{"content":"流れ 今作ってるbotでMySQLを使いたくなったので、使ってみる。 作ってるのはhttps://github.com/tbistr/gs-linker。\n参考 MySQLのチュートリアルサイト? https://www.mysqltutorial.org/getting-started-with-mysql/ を参考にした。\n環境はVagrantで作った。 Boxはbento/ubuntu-20.04。\nインストール チュートリアルサイトでのインストールの手順では、 sudo mysql_secure_installationでどんなパスワードを設定しても\n... Failed! Error: SET PASSWORD has no significance for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; as the authentication method used doesn\u0026#39;t store authentication data in the MySQL server. Please consider using ALTER USER instead if you want to change authentication parameters. のエラーで失敗する。\nそのため、sudo mysql_secure_installationの前に、\nsudo mysql mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;適当なパスワード\u0026#39;; mysql\u0026gt; exit を実行した。\nあとは手順通り、すべてyでOK。\n一応確認、\nsudo mysql -u root -p mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.02 sec) できとるがね。(河村市長)\n","permalink":"https://tbistr.github.io/posts/tech/mysql_tutorial/","summary":"流れ 今作ってるbotでMySQLを使いたくなったので、使ってみる。 作ってるのはhttps://github.com/tbistr/gs-linker。\n参考 MySQLのチュートリアルサイト? https://www.mysqltutorial.org/getting-started-with-mysql/ を参考にした。\n環境はVagrantで作った。 Boxはbento/ubuntu-20.04。\nインストール チュートリアルサイトでのインストールの手順では、 sudo mysql_secure_installationでどんなパスワードを設定しても\n... Failed! Error: SET PASSWORD has no significance for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; as the authentication method used doesn\u0026#39;t store authentication data in the MySQL server. Please consider using ALTER USER instead if you want to change authentication parameters. のエラーで失敗する。\nそのため、sudo mysql_secure_installationの前に、\nsudo mysql mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;適当なパスワード\u0026#39;; mysql\u0026gt; exit を実行した。\nあとは手順通り、すべてyでOK。\n一応確認、\nsudo mysql -u root -p mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.","title":"MySQLのチュートリアルでコケた"},{"content":"概要 原因はUSBでつながっていたXInputのコントローラ。 デバイスを抜くことで解決。\n状況 症状 VirtualboxのGUIが起動しない vagrant upが失敗する VBoxManage.exeコマンドに応答がない helpは表示できるが、vmのリスト等は出ない 環境 i7-12700 32gb windows11 pro virtualbox 6.1.32 chocolateyでインストール wsl, dockerがインストールされている ハイパーバイザプラットフォーム有効化済み 確認したこと、やってみたこと タスクマネージャの確認 virtualboxの再インストール vagrantの再インストール OSのクリーンインストール タスクマネージャの確認 「バックグラウンドプロセス」のタブにこの3つのプロセスが存在した。\nVirtualbox Interface Virtualbox Global Interface Virtualbox Manager 本来は、Virtualbox Managerは「アプリ」のタブにあるべき。 起動を試みるたびに、Virtualbox Managerは増えていき、ゾンビプロセスになった。\nvirtualbox, vagrantの再インストール chocolatey版、msiインストーラ版両方試したが効果なし。\nOSのクリーンインストール しばらくは問題が起きなくなったが、ある日突然再発。\n原因と解決方法 VM起動時にエラーが発生し、いつもどおり原因をググっていたところ、同じような問題がOracleのフォーラムに投稿されていることに気がついた。\nhttps://forums.virtualbox.org/viewtopic.php?t=97261\n昨年10月に、このような投稿があった。\nRe: GUI not appearing\nPostby LeonJi » 4. Oct 2021, 04:11\nI also got this problem this morning.\nFinally, I found an usb device(wireless adaptor for game controller) was the root cause.\nAfter removing this device, the GUI appeared immediately.\nSo I guess , VB detects the usb devices and can not recogize it , some how it comes into an infinite loop before completing the initialization process.\n要約すると、 「根本的な原因はゲームのコントローラが接続されていることだった。アプリの初期化時にUSBデバイスを見ており、コントローラを抜いたら解決した。」 と言っている。\n私のPCにもUSBゲームコントローラが有線接続しっぱなしになっていたので、取り除いてvirtualboxを起動してみたところ、正常に起動した。\nやはり原因としてはフォーラムの投稿にあるように、「初期化時にUSBデバイスをチェックするが、ゲームのコントローラに対応できずに無限ループになる。」ということであると考えられる。\nタイムアウト処理か、起動後にチェックするようにして欲しいが、バグ報告はOracle会員にならないといけないし、フォーラム経由で既に開発チームに認識されているっぽいので放置。\nおまけ 使っていたコントローラはこれ。\nhttps://www.amazon.co.jp/gp/product/B08NPJ1GTC\n普通に質が良く、ジャイロ対応でSwitchでもPCでも安定して使えるのでオススメ。\n","permalink":"https://tbistr.github.io/posts/tech/vb_usb_bug/","summary":"概要 原因はUSBでつながっていたXInputのコントローラ。 デバイスを抜くことで解決。\n状況 症状 VirtualboxのGUIが起動しない vagrant upが失敗する VBoxManage.exeコマンドに応答がない helpは表示できるが、vmのリスト等は出ない 環境 i7-12700 32gb windows11 pro virtualbox 6.1.32 chocolateyでインストール wsl, dockerがインストールされている ハイパーバイザプラットフォーム有効化済み 確認したこと、やってみたこと タスクマネージャの確認 virtualboxの再インストール vagrantの再インストール OSのクリーンインストール タスクマネージャの確認 「バックグラウンドプロセス」のタブにこの3つのプロセスが存在した。\nVirtualbox Interface Virtualbox Global Interface Virtualbox Manager 本来は、Virtualbox Managerは「アプリ」のタブにあるべき。 起動を試みるたびに、Virtualbox Managerは増えていき、ゾンビプロセスになった。\nvirtualbox, vagrantの再インストール chocolatey版、msiインストーラ版両方試したが効果なし。\nOSのクリーンインストール しばらくは問題が起きなくなったが、ある日突然再発。\n原因と解決方法 VM起動時にエラーが発生し、いつもどおり原因をググっていたところ、同じような問題がOracleのフォーラムに投稿されていることに気がついた。\nhttps://forums.virtualbox.org/viewtopic.php?t=97261\n昨年10月に、このような投稿があった。\nRe: GUI not appearing\nPostby LeonJi » 4. Oct 2021, 04:11\nI also got this problem this morning.\nFinally, I found an usb device(wireless adaptor for game controller) was the root cause.","title":"Virtualbox Manager (GUI)が起動しないバグと解決方法"},{"content":"概要 卒論のために久しぶりにTeX環境を作る必要があったので、TeX Liveがfullでインストールされたコンテナイメージを探していたのですが、無かったので作りました。 通常のインストール手順ではハマるポイントがあったのでパッケージマネージャを使わない方法でインストールしました。\ndevcontainer化することで、vscodeから立ち上げるだけで補完、プレビューが使えるようになっています。\ndevcontainer devcontainerとは、vscodeの（拡張）機能の1つで、これを利用することで用意したコンテナの中にワークスペースフォルダをマウントし、コンテナ内のコマンド、環境を使うことができます。 また、拡張機能、設定についても指定したものを使うことができます（ローカルのvscodeにはインストールされません）。 これにより、環境の分離、チーム内での共通化ができます。\n参考：devcontainerのチュートリアル\nネット上に存在するTeX用Dockerイメージ ネット上には、フルインストール版、日本語に必要なモジュールに限定した版の両方について、様々なイメージが存在しています。 しかし、日本語環境がうまく入らない、texindex（フォーマッタ）が動作しないなど、日本語環境で常用するには不具合が発生しました。 執筆中に試してみたら、公式が配布しているtexlive/texliveイメージはちゃんと全部動きました。。。まあ、見なかったことにします。 また、fullと謳っていながら実際にはモジュールに不足があるイメージもあります（主に日本語関係のモジュールがない）。\n制作内容 全容はGithubのリポジトリから参照できます。\ntex.profile texを非対話的に（ビルド時にユーザーがオプション等を選択しない）インストールするのに必要な設定ファイルです。 今回は、このファイルによるスキーマ指定がしたかったため、aptは使わずに、ソースからインストールしています。\nselected_scheme scheme-fullでfullバージョンを指定しています。\nその他で肝要な部分は、option_doc 0とoption_src 0です。 fullでインストールすると、ドキュメントとソースを含むだけで2GB近く消費してしまいます。 そのため、このオプションで除外しておきます。\nselected_scheme scheme-full TEXDIR /opt/texlive/2021 TEXMFCONFIG ~/.texlive2021/texmf-config TEXMFHOME ~/texmf TEXMFLOCAL /opt/texlive/texmf-local TEXMFSYSCONFIG /opt/texlive/2021/texmf-config TEXMFSYSVAR /opt/texlive/2021/texmf-var TEXMFVAR ~/.texlive2021/texmf-var binary_x86_64-darwin 0 binary_x86_64-linux 1 binary_win32 0 option_doc 0 option_src 0 option_adjustrepo 0 余談ですが、この設定ファイルの書式、TeX Liveのリファレンスにも見つけられませんでした（一度デフォルト設定でビルドすると出力されるから、それを改変しろ。ということらしい。）\nDockerfile 本体となるDocekrfileです。 ベースにはmicrosoftが公開しているdevcontainer用に設定されたイメージを使用しました。 基本的なutil系コマンドがインストール済みです。\nそれ以降の処理はコメントに記載してあるとおりです。\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-21.04 COPY tex.profile ./ # 日本のミラーサーバからTeX Live 2021をダウンロードしてくる RUN wget https://texlive.texjp.org/2021/tlnet/install-tl-unx.tar.gz \\ \u0026amp;\u0026amp; mkdir install-tl \\ \u0026amp;\u0026amp; tar xzf install-tl-unx.tar.gz -C install-tl --strip-components 1 \\ # 解凍 \u0026amp;\u0026amp; ./install-tl/install-tl \\ # インストールスクリプトを起動 --profile ./tex.profile \\ # 先述のプロファイルを指定する --repository http://texlive.texjp.org/2021/tlnet \\ # 依存のDL元も日本のミラーサーバ \u0026amp;\u0026amp; rm -r install-tl-unx.tar.gz install-tl # latexindentを使うために必要なperlのモジュールをaptで取得する。 # cpan（perlのパッケージマネージャ）でのインストールはperl外の依存（makeとか）を必要とするため、対応するものをaptで探した。 RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y --no-install-recommends \\ libyaml-tiny-perl \\ libfile-homedir-perl \\ libunicode-linebreak-perl \\ \u0026amp;\u0026amp; apt-get autoremove -y \\ \u0026amp;\u0026amp; apt-get clean -y \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* USER vscode # 環境変数の更新 RUN echo \u0026#39;export PATH=\u0026#34;$PATH:/opt/texlive/2021/bin/x86_64-linux\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc また、本番リポジトリではこのDockerfileをビルド、Dockerhubにアップしたものをpullしてくる様になっています。 そのため、通常のtexliveのインストール、ビルドよりも大幅に短期間でセットアップできます。 （一度pullしておけば再起動は爆速。）\nその他 latexmkrc（texからPDFへのビルド手順を定義したファイル）と、settings.json（vscodeの設定）については、このリポジトリを参考にしています。\nまとめ 以上の内容をテンプレートリポジトリとしてこちらにアップしました。 補完、フォーマットも効いて、エラーは該当ラインに表示、ファイルの保存時に自動的にビルドするなど、手間の割になかなか便利に使えると思います。 是非使ってみてください。\n","permalink":"https://tbistr.github.io/posts/tech/tex_devcontainer/","summary":"概要 卒論のために久しぶりにTeX環境を作る必要があったので、TeX Liveがfullでインストールされたコンテナイメージを探していたのですが、無かったので作りました。 通常のインストール手順ではハマるポイントがあったのでパッケージマネージャを使わない方法でインストールしました。\ndevcontainer化することで、vscodeから立ち上げるだけで補完、プレビューが使えるようになっています。\ndevcontainer devcontainerとは、vscodeの（拡張）機能の1つで、これを利用することで用意したコンテナの中にワークスペースフォルダをマウントし、コンテナ内のコマンド、環境を使うことができます。 また、拡張機能、設定についても指定したものを使うことができます（ローカルのvscodeにはインストールされません）。 これにより、環境の分離、チーム内での共通化ができます。\n参考：devcontainerのチュートリアル\nネット上に存在するTeX用Dockerイメージ ネット上には、フルインストール版、日本語に必要なモジュールに限定した版の両方について、様々なイメージが存在しています。 しかし、日本語環境がうまく入らない、texindex（フォーマッタ）が動作しないなど、日本語環境で常用するには不具合が発生しました。 執筆中に試してみたら、公式が配布しているtexlive/texliveイメージはちゃんと全部動きました。。。まあ、見なかったことにします。 また、fullと謳っていながら実際にはモジュールに不足があるイメージもあります（主に日本語関係のモジュールがない）。\n制作内容 全容はGithubのリポジトリから参照できます。\ntex.profile texを非対話的に（ビルド時にユーザーがオプション等を選択しない）インストールするのに必要な設定ファイルです。 今回は、このファイルによるスキーマ指定がしたかったため、aptは使わずに、ソースからインストールしています。\nselected_scheme scheme-fullでfullバージョンを指定しています。\nその他で肝要な部分は、option_doc 0とoption_src 0です。 fullでインストールすると、ドキュメントとソースを含むだけで2GB近く消費してしまいます。 そのため、このオプションで除外しておきます。\nselected_scheme scheme-full TEXDIR /opt/texlive/2021 TEXMFCONFIG ~/.texlive2021/texmf-config TEXMFHOME ~/texmf TEXMFLOCAL /opt/texlive/texmf-local TEXMFSYSCONFIG /opt/texlive/2021/texmf-config TEXMFSYSVAR /opt/texlive/2021/texmf-var TEXMFVAR ~/.texlive2021/texmf-var binary_x86_64-darwin 0 binary_x86_64-linux 1 binary_win32 0 option_doc 0 option_src 0 option_adjustrepo 0 余談ですが、この設定ファイルの書式、TeX Liveのリファレンスにも見つけられませんでした（一度デフォルト設定でビルドすると出力されるから、それを改変しろ。ということらしい。）\nDockerfile 本体となるDocekrfileです。 ベースにはmicrosoftが公開しているdevcontainer用に設定されたイメージを使用しました。 基本的なutil系コマンドがインストール済みです。\nそれ以降の処理はコメントに記載してあるとおりです。\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-21.04 COPY tex.profile ./ # 日本のミラーサーバからTeX Live 2021をダウンロードしてくる RUN wget https://texlive.","title":"texlive2021の最強環境を作ったよ"},{"content":"何がしたいか Vagrantで立てたVMについて、デスクトップ環境(GNOMEとかLXDEとか)を導入して、GUI環境を実現させる方法は様々な紹介されている。\nしかし、デスクトップ環境の導入をすると、プロビジョニングのステップでapt-get install ubuntu-desktopなどする必要があり、めちゃめちゃ時間がかかる。\nここでは、VM内のアプリケーションをwindows上のウィンドウとして描画させることを目指す。\n仕組み 用語 X Window System (X11) linuxがデファクトで使っている、ウィンドウ表示プロトコル。 X11クライアント 画面を描画してもらうアプリケーション。 今回の場合、ゲストOS上で動くアプリケーション。 X11サーバー 画面を描画する側。 今回の場合、ホストOSのウィンドウシステム。 vcXsrv 今回使うwindows向けX11サーバー。 X11サーバーは色々種類があるが、最近はこれが主流らしい。 実際の動き 下図のように、SSH経由で送信。 実践 準備 Chocolateyを使っているので、choco install vcxsrvでvcXsrvをインストール。\n(https://sourceforge.net/projects/vcxsrv/ からもインストールできる)\n起動すると設定項目が出る。 すべて初期設定で問題ない。\nタスクバーにX11のロゴが出ていたら準備完了。(簡単！！！)\nVagrantファイルの用意 最終的に、以下のようなVagrantファイルを用意する。\nVagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.box = \u0026#34;bento/ubuntu-20.10\u0026#34; config.ssh.forward_x11 = true config.vm.provision \u0026#34;shell\u0026#34;, inline: \u0026lt;\u0026lt;-SHELL apt-get update apt-get upgrade SHELL config.vm.provision \u0026#34;shell\u0026#34;, privileged: false, inline: \u0026lt;\u0026lt;-SHELL echo \u0026#34;export DISPLAY=10.0.2.2:0\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile SHELL end そこまで解説することはないが、少しだけ。\nconfig.ssh.forward_x11 = trueは、X11を有効化するオプション。 これをtrueに設定することで、vagrant sshで接続したときに自動でx11を転送してくれる。\necho \u0026quot;export DISPLAY=10.0.2.2:0\u0026quot; \u0026gt;\u0026gt; ~/.bash_profileでは、X11でどこに描画するかを設定する。 virtual boxでは、ゲストからホストは10.0.2.2でアクセスすることができるので、このように設定する。\nprivileged: falseはプロビジョニングを非ルートユーザー(デフォはvagrantユーザー)で実行する設定。 これで~/がユーザーのホームになる。\n","permalink":"https://tbistr.github.io/posts/tech/vagrant_x11/","summary":"何がしたいか Vagrantで立てたVMについて、デスクトップ環境(GNOMEとかLXDEとか)を導入して、GUI環境を実現させる方法は様々な紹介されている。\nしかし、デスクトップ環境の導入をすると、プロビジョニングのステップでapt-get install ubuntu-desktopなどする必要があり、めちゃめちゃ時間がかかる。\nここでは、VM内のアプリケーションをwindows上のウィンドウとして描画させることを目指す。\n仕組み 用語 X Window System (X11) linuxがデファクトで使っている、ウィンドウ表示プロトコル。 X11クライアント 画面を描画してもらうアプリケーション。 今回の場合、ゲストOS上で動くアプリケーション。 X11サーバー 画面を描画する側。 今回の場合、ホストOSのウィンドウシステム。 vcXsrv 今回使うwindows向けX11サーバー。 X11サーバーは色々種類があるが、最近はこれが主流らしい。 実際の動き 下図のように、SSH経由で送信。 実践 準備 Chocolateyを使っているので、choco install vcxsrvでvcXsrvをインストール。\n(https://sourceforge.net/projects/vcxsrv/ からもインストールできる)\n起動すると設定項目が出る。 すべて初期設定で問題ない。\nタスクバーにX11のロゴが出ていたら準備完了。(簡単！！！)\nVagrantファイルの用意 最終的に、以下のようなVagrantファイルを用意する。\nVagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.box = \u0026#34;bento/ubuntu-20.10\u0026#34; config.ssh.forward_x11 = true config.vm.provision \u0026#34;shell\u0026#34;, inline: \u0026lt;\u0026lt;-SHELL apt-get update apt-get upgrade SHELL config.vm.provision \u0026#34;shell\u0026#34;, privileged: false, inline: \u0026lt;\u0026lt;-SHELL echo \u0026#34;export DISPLAY=10.0.2.2:0\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile SHELL end そこまで解説することはないが、少しだけ。\nconfig.ssh.forward_x11 = trueは、X11を有効化するオプション。 これをtrueに設定することで、vagrant sshで接続したときに自動でx11を転送してくれる。","title":"Vagrantでデスクトップ環境はいらないけど、GUIアプリを使いたい"},{"content":"今回使ったツールなど hugo hugoは、go言語で書かれた静的サイトジェネレータ。 markdownで記事を書くことができ、有志が開発したテーマによって、簡単にキレイなサイトを作ることができる。\nhttps://gohugo.io/about/what-is-hugo/\ngithub pages githubのリポジトリに置いたファイル群を、専用のURL(独自ドメインもおk)に紐づけてホスティングしてくれるサービス。\nhttps://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages\ngithub actions githubに対するpush, pull requestなどのアクションをトリガにして、ビルドや他サービスへのデプロイ、テストなどのアクションを実行してくれるサービス。(CI/CDとかいうやつですかね。)\nhttps://docs.github.com/ja/actions\nやってみる hugo https://gohugo.io/getting-started/quick-start/\nlinuxbrewに対応しているので、brew install hugoでインストールした。 windowsだとchocolatey、macだとhomebrewでインストールするのが楽だと思う。\n公式のクイックスタートガイドに沿って、ローカルで使い方を確認する。\nテーマ選び hugoでは複数テーマを好きなときに切り替えられるようになっているが、設定項目も全然違うので、気軽に切り替えるようなもんでもない。 そのため、ローカルで多少吟味してから決めると良さそう。\n今回は、以下の項目を評価して決めた。\n必須の設定項目が多すぎない。 リポジトリやホームページに情報がちゃんと載ってる。 exampleサイトの実装がある。(情報がカスでも、最悪写せる。) 最新の更新が新しめ。 上3つを考慮してanankeを考えていたが、更新が途絶えていたためpaper-modを選択した。\n(おまけ)テーマの適用方法について ネット上の記事ではgit submoduleを使ってテーマを管理する方法が主流になっているが、最新版ではhugo modulesという機能を使うことができる。\n詳細は以下のURLを参考にして欲しいが、モジュール初期化後にconfig.ymlにインポートしたいパッケージ名を書けば良い。 (載ってないが、テーマの指定部分にパッケージ名を書くだけでいける。)\n中身はgo modulesを使っているらしい。\ngithub 普通にリポジトリを作成してpagesを設定すると、URLはhtps://[user_name].github.io/[repo_name]/になる。 自分のホームページ的な運用をしたいのであれば、リポジトリ名をuser_name.github.ioにすることで、https://[user_name].github.io/でホスティングしてくれる。\nとりあえず好きな方でリポジトリを作成し、hugoのディレクトリとしてhugo new siteしてプッシュする。\ngithub actions 今回は、mainブランチにpushしたときにビルドを走らせて、ホスティング対象となるファイルをgh-pagesブランチにcommitしてくれるactionsを採用した。 先人が必要な記述を用意してくれているので、ほぼそのままパクる。\nhttps://github.com/peaceiris/actions-hugo#getting-started を参考に、.github/worlflows/gh-pages.ymlを作成して、中身はそのままコピペする。 適当にコミットしてみて、リポジトリのactionsタブから、正常にビルドができていることを確認する。(コケてたら、hugo-versionをローカルと合わせてみると多分うまくいく。)\ngithub pages 作成したリポジトリのsettingsタブから、pages項目を開き、Sourceのブランチをgh-pages、ディレクトリを/rootに設定する。 (先述のactionsによるビルドが成功していれば、ブランチは自動で作成されているはず。)\nhugoの設定をイジる 必須な項目として、config.ymlのbaseURLを、pagesが対象にするURLに合わせる必要がある。 このサイトならhttps://tbistr.github.io/、pagesタブでYour site is published at https://ほげとされているURL。\nあとはローカルのhugo serverで確認しつつ好きなように設定する。\n","permalink":"https://tbistr.github.io/posts/tech/hugo_hands_on/","summary":"今回使ったツールなど hugo hugoは、go言語で書かれた静的サイトジェネレータ。 markdownで記事を書くことができ、有志が開発したテーマによって、簡単にキレイなサイトを作ることができる。\nhttps://gohugo.io/about/what-is-hugo/\ngithub pages githubのリポジトリに置いたファイル群を、専用のURL(独自ドメインもおk)に紐づけてホスティングしてくれるサービス。\nhttps://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages\ngithub actions githubに対するpush, pull requestなどのアクションをトリガにして、ビルドや他サービスへのデプロイ、テストなどのアクションを実行してくれるサービス。(CI/CDとかいうやつですかね。)\nhttps://docs.github.com/ja/actions\nやってみる hugo https://gohugo.io/getting-started/quick-start/\nlinuxbrewに対応しているので、brew install hugoでインストールした。 windowsだとchocolatey、macだとhomebrewでインストールするのが楽だと思う。\n公式のクイックスタートガイドに沿って、ローカルで使い方を確認する。\nテーマ選び hugoでは複数テーマを好きなときに切り替えられるようになっているが、設定項目も全然違うので、気軽に切り替えるようなもんでもない。 そのため、ローカルで多少吟味してから決めると良さそう。\n今回は、以下の項目を評価して決めた。\n必須の設定項目が多すぎない。 リポジトリやホームページに情報がちゃんと載ってる。 exampleサイトの実装がある。(情報がカスでも、最悪写せる。) 最新の更新が新しめ。 上3つを考慮してanankeを考えていたが、更新が途絶えていたためpaper-modを選択した。\n(おまけ)テーマの適用方法について ネット上の記事ではgit submoduleを使ってテーマを管理する方法が主流になっているが、最新版ではhugo modulesという機能を使うことができる。\n詳細は以下のURLを参考にして欲しいが、モジュール初期化後にconfig.ymlにインポートしたいパッケージ名を書けば良い。 (載ってないが、テーマの指定部分にパッケージ名を書くだけでいける。)\n中身はgo modulesを使っているらしい。\ngithub 普通にリポジトリを作成してpagesを設定すると、URLはhtps://[user_name].github.io/[repo_name]/になる。 自分のホームページ的な運用をしたいのであれば、リポジトリ名をuser_name.github.ioにすることで、https://[user_name].github.io/でホスティングしてくれる。\nとりあえず好きな方でリポジトリを作成し、hugoのディレクトリとしてhugo new siteしてプッシュする。\ngithub actions 今回は、mainブランチにpushしたときにビルドを走らせて、ホスティング対象となるファイルをgh-pagesブランチにcommitしてくれるactionsを採用した。 先人が必要な記述を用意してくれているので、ほぼそのままパクる。\nhttps://github.com/peaceiris/actions-hugo#getting-started を参考に、.github/worlflows/gh-pages.ymlを作成して、中身はそのままコピペする。 適当にコミットしてみて、リポジトリのactionsタブから、正常にビルドができていることを確認する。(コケてたら、hugo-versionをローカルと合わせてみると多分うまくいく。)\ngithub pages 作成したリポジトリのsettingsタブから、pages項目を開き、Sourceのブランチをgh-pages、ディレクトリを/rootに設定する。 (先述のactionsによるビルドが成功していれば、ブランチは自動で作成されているはず。)\nhugoの設定をイジる 必須な項目として、config.ymlのbaseURLを、pagesが対象にするURLに合わせる必要がある。 このサイトならhttps://tbistr.github.io/、pagesタブでYour site is published at https://ほげとされているURL。\nあとはローカルのhugo serverで確認しつつ好きなように設定する。","title":"hugoお試ししてみた。"},{"content":"基本情報 坪井正太郎といいます。 名古屋大学情報学部でCS、特に組込みシステムについて学んでいます。\nGo言語をよく書いていますが、Kotlinが好きです。Rustにも興味があり、組み込みRustとかを頑張っています。\n趣味はバイクで、HONDAの400Xに乗ってます。旅はそんなに好きじゃないので、毎日名古屋市内を流してます。\nそんなかんじ。追記するかも。\n","permalink":"https://tbistr.github.io/posts/about_me/","summary":"基本情報 坪井正太郎といいます。 名古屋大学情報学部でCS、特に組込みシステムについて学んでいます。\nGo言語をよく書いていますが、Kotlinが好きです。Rustにも興味があり、組み込みRustとかを頑張っています。\n趣味はバイクで、HONDAの400Xに乗ってます。旅はそんなに好きじゃないので、毎日名古屋市内を流してます。\nそんなかんじ。追記するかも。","title":"自己紹介"}]